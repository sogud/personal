---
interface Props {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  caption?: string;
  priority?: boolean;
  className?: string;
  sizes?: string;
}

const { 
  src, 
  alt, 
  width, 
  height, 
  caption, 
  priority = false,
  className = '',
  sizes = '(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw'
} = Astro.props;

// 生成不同尺寸的图片 URL
const generateImageSrc = (originalSrc: string, width: number) => {
  // 这里可以集成图片 CDN 服务，如 Cloudinary, ImageKit 等
  // 目前返回原始 URL，实际项目中应该使用图片优化服务
  return originalSrc;
};

// 生成 WebP 格式的图片 URL
const generateWebPSrc = (originalSrc: string) => {
  // 实际项目中应该生成 WebP 格式的图片
  return originalSrc.replace(/\.(jpg|jpeg|png)$/i, '.webp');
};

// 生成占位符
const generatePlaceholder = (width: number, height: number) => {
  const svg = `
    <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
      <rect width="100%" height="100%" fill="#f3f4f6"/>
      <text x="50%" y="50%" text-anchor="middle" dy=".3em" fill="#9ca3af" font-family="system-ui, sans-serif" font-size="14">
        加载中...
      </text>
    </svg>
  `;
  return `data:image/svg+xml;base64,${Buffer.from(svg).toString('base64')}`;
};
---

<div class="image-container">
  <picture>
    <!-- WebP 格式 -->
    <source 
      srcset={generateWebPSrc(src)} 
      type="image/webp"
      sizes={sizes}
    />
    
    <!-- 原始格式 -->
    <img
      src={src}
      alt={alt}
      width={width}
      height={height}
      loading={priority ? "eager" : "lazy"}
      decoding="async"
      class={`optimized-image ${className}`}
      sizes={sizes}
      style={`
        background-image: url('${generatePlaceholder(width || 400, height || 300)}');
        background-size: cover;
        background-position: center;
      `}
      onload="this.style.backgroundImage='none'"
    />
  </picture>
  
  {caption && (
    <figcaption class="image-caption">
      {caption}
    </figcaption>
  )}
</div>

<style>
  .image-container {
    position: relative;
    display: block;
    width: 100%;
  }

  .optimized-image {
    width: 100%;
    height: auto;
    display: block;
    border-radius: 8px;
    transition: opacity 0.3s ease;
  }

  .optimized-image[loading="lazy"] {
    opacity: 0;
    animation: fadeIn 0.5s ease-in-out forwards;
  }

  .image-caption {
    margin-top: 0.5rem;
    font-size: 0.875rem;
    color: #6b7280;
    text-align: center;
    font-style: italic;
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
    }
    to {
      opacity: 1;
    }
  }

  /* 深色模式 */
  @media (prefers-color-scheme: dark) {
    .image-caption {
      color: #9ca3af;
    }
  }

  /* 响应式图片 */
  .optimized-image {
    max-width: 100%;
    height: auto;
  }

  /* 加载状态 */
  .optimized-image:not([src]) {
    background-color: #f3f4f6;
    min-height: 200px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* 错误状态 */
  .optimized-image[src=""],
  .optimized-image:not([src]) {
    background-color: #f3f4f6;
    color: #9ca3af;
  }
</style>

<script>
  // 图片懒加载和错误处理
  document.addEventListener('DOMContentLoaded', function() {
    const images = document.querySelectorAll('.optimized-image[loading="lazy"]');
    
    if ('IntersectionObserver' in window) {
      const imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target as HTMLImageElement;
            
            // 预加载图片
            const tempImg = new Image();
            tempImg.onload = () => {
              img.src = tempImg.src;
              img.style.opacity = '1';
            };
            tempImg.onerror = () => {
              img.style.backgroundColor = '#f3f4f6';
              img.style.color = '#9ca3af';
              img.style.display = 'flex';
              img.style.alignItems = 'center';
              img.style.justifyContent = 'center';
              img.textContent = '图片加载失败';
            };
            tempImg.src = img.dataset.src || img.src;
            
            observer.unobserve(img);
          }
        });
      }, {
        rootMargin: '50px 0px',
        threshold: 0.01
      });

      images.forEach(img => {
        if (img.dataset.src) {
          imageObserver.observe(img);
        }
      });
    }

    // 图片加载错误处理
    images.forEach(img => {
      img.addEventListener('error', function() {
        this.style.backgroundColor = '#f3f4f6';
        this.style.color = '#9ca3af';
        this.style.display = 'flex';
        this.style.alignItems = 'center';
        this.style.justifyContent = 'center';
        this.textContent = '图片加载失败';
      });
    });
  });

  // 图片预加载功能
  function preloadImage(src: string): Promise<HTMLImageElement> {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  }

  // 批量预加载图片
  function preloadImages(srcs: string[]): Promise<HTMLImageElement[]> {
    return Promise.all(srcs.map(src => preloadImage(src)));
  }

  // 导出函数供其他组件使用
  (window as any).preloadImage = preloadImage;
  (window as any).preloadImages = preloadImages;
</script>
